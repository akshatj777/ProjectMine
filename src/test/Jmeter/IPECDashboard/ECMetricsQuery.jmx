<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="4.0" jmeter="4.0 r1823414">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
        <stringProp name="dataSource">MySQLQA</stringProp>
        <stringProp name="poolMax">10</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="checkQuery">Select 1</stringProp>
        <stringProp name="dbUrl">jdbc:mysql://rds-qa.remedypartners.com:3306/warehouse</stringProp>
        <stringProp name="driver">com.mysql.jdbc.Driver</stringProp>
        <stringProp name="username">salam</stringProp>
        <stringProp name="password">1Welcome2</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="IPEC Dashboard" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <intProp name="LoopController.loops">-1</intProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1511452775000</longProp>
        <longProp name="ThreadGroup.end_time">1511452775000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <OnceOnlyController guiclass="OnceOnlyControllerGui" testclass="OnceOnlyController" testname="Once Only Controller" enabled="true"/>
        <hashTree>
          <SystemSampler guiclass="SystemSamplerGui" testclass="SystemSampler" testname="OS Process Sampler" enabled="false">
            <boolProp name="SystemSampler.checkReturnCode">false</boolProp>
            <stringProp name="SystemSampler.expectedReturnCode">0</stringProp>
            <stringProp name="SystemSampler.command">cmd.exe</stringProp>
            <elementProp name="SystemSampler.arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="Argument">
                  <stringProp name="Argument.name"></stringProp>
                  <stringProp name="Argument.value">-c</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
                <elementProp name="" elementType="Argument">
                  <stringProp name="Argument.name"></stringProp>
                  <stringProp name="Argument.value">echo &quot;ECEpiosdeCount,claimsEpiosdeCount,savingRate,TotalNPRA, TotalProgram&quot; &gt;&gt; PerformanceDashboardResult.txt</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <elementProp name="SystemSampler.environment" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="SystemSampler.directory">C:\Users\sandeep.singh\Desktop\Tableautestpaln</stringProp>
          </SystemSampler>
          <hashTree/>
        </hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="NumberOfEppisode" enabled="true">
          <stringProp name="filename">IPECECMetricsInput.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames">Flag,time_range,bpid,ccn,bundle,region,market,r_region,r_market,participantName</stringProp>
          <stringProp name="delimiter">|</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
          <boolProp name="ignoreFirstLine">false</boolProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Eligibility Capture Rate" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select round((sum(if(eligibility in (&apos;ELIGIBLE&apos;,  &apos;EXPIRED&apos;, &apos;UNKNOWN&apos;, &apos;NOT_ELIGIBLE&apos;),1,0))/sum(Episodes)),3) * 100 as `Eligibility Capture Rate`
from (
SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post Acute CCN Name&apos;,
    adf.ccn as &apos;post Acute CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor facility CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date of Birth&apos;,
    dp.dod as &apos;Date of Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed Physician NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,
    dn.DischargeType AS &apos;Next Site of Care Category&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;, &apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
 )a;</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">Episode_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="1037289360">
                <stringProp name="1168425087">select round((sum(if(eligibility in (&apos;ELIGIBLE&apos;,  &apos;EXPIRED&apos;, &apos;UNKNOWN&apos;, &apos;NOT_ELIGIBLE&apos;),1,0))/sum(Episodes)),3) * 100 as `Eligibility Capture Rate` from ( SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post Acute CCN Name&apos;,     adf.ccn as &apos;post Acute CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor facility CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date of Birth&apos;,     dp.dod as &apos;Date of Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed Physician NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,     dn.DischargeType AS &apos;Next Site of Care Category&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;, &apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() e.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME}  )a; </stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Eligibility Error Episode Count" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select count(*) as `Error`
from
(
SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post Acute CCN Name&apos;,
    adf.ccn as &apos;post Acute CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor facility CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date of Birth&apos;,
    dp.dod as &apos;Date of Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed Physician NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,
    dn.DischargeType AS &apos;Next Site of Care Category&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dp.eligibility = &apos;ERROR&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
)a;</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">savingRate_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="-1515406159">
                <stringProp name="1575879557">select count(*) as `Error` from ( SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post Acute CCN Name&apos;,     adf.ccn as &apos;post Acute CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor facility CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date of Birth&apos;,     dp.dod as &apos;Date of Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed Physician NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,     dn.DischargeType AS &apos;Next Site of Care Category&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dp.eligibility = &apos;ERROR&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} )a;</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Onboarding Rate" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select sum(numerator)/sum(denominator) * 100 as `Onboarding Rate`
from
(select Episodes as denominator,CASE
	WHEN Onboarding_Status in (&apos;Unknown&apos;,&apos;Not Onboarded&apos;,&apos;Onboarded&apos;) THEN 1
    ELSE 0
   END as numerator 
from
(
SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post Acute CCN Name&apos;,
    adf.ccn as &apos;post Acute CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor facility CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date of Birth&apos;,
    dp.dod as &apos;Date of Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding_Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed Physician NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,
    dn.DischargeType AS &apos;Next Site of Care Category&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
)a
)b;</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">TotalNPRA_EC_Claims, TotalProgram_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="1867532908">
                <stringProp name="2011053211">select sum(numerator)/sum(denominator) * 100 as `Onboarding Rate` from (select Episodes as denominator,CASE 	WHEN Onboarding_Status in (&apos;Unknown&apos;,&apos;Not Onboarded&apos;,&apos;Onboarded&apos;) THEN 1     ELSE 0    END as numerator  from ( SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post Acute CCN Name&apos;,     adf.ccn as &apos;post Acute CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor facility CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date of Birth&apos;,     dp.dod as &apos;Date of Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding_Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed Physician NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,     dn.DischargeType AS &apos;Next Site of Care Category&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} )a )b;</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Needs Onboard Metric Validation" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select sum(numerator) as `Needs Onboarding`
from
(select Episodes as denominator,CASE
	WHEN Onboarding_Status in (&apos;Needs Onboarding&apos;) THEN 1
    ELSE 0
   END as numerator 
from
(
SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post Acute CCN Name&apos;,
    adf.ccn as &apos;post Acute CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor facility CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date of Birth&apos;,
    dp.dod as &apos;Date of Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding_Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed Physician NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,
    dn.DischargeType AS &apos;Next Site of Care Category&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
)a
)b;  </stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">DischargeToSNF_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}	
	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="455756754">
                <stringProp name="-647329013">select sum(numerator) as `Needs Onboarding` from (select Episodes as denominator,CASE 	WHEN Onboarding_Status in (&apos;Needs Onboarding&apos;) THEN 1     ELSE 0    END as numerator  from ( SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post Acute CCN Name&apos;,     adf.ccn as &apos;post Acute CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor facility CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date of Birth&apos;,     dp.dod as &apos;Date of Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding_Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed Physician NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,     dn.DischargeType AS &apos;Next Site of Care Category&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} )a )b;  </stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="NSOC Completion rate" enabled="true">
          <stringProp name="TestPlan.comments">	</stringProp>
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select sum(Specified)/sum(denominator) * 100 as `NSOC Completion Rate`
from
(
select Episodes as denominator,
case when  post_Acute_CCN is not null then 1 /*Previously */
else 0
end as Specified,
NSOC
from(
SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post_Acute_CCN_Name&apos;,
    adf.ccn as &apos;post_Acute_CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor_facility_CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date_of_Birth&apos;,
    dp.dod as &apos;Date_of_Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding_Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed_Physician_NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed_Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC_Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC_Network_Tier&apos;,
    dn.DischargeType AS &apos;NSOC&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
)
a)b
where NSOC not in (&apos;Home&apos;, &apos;Entry Error&apos;, &apos;Invalid&apos;);</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">dischtoSNFBenchmark_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}	
	
	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="1291917033">
                <stringProp name="-1606542295">select sum(Specified)/sum(denominator) * 100 as `NSOC Completion Rate` from ( select Episodes as denominator, case when  post_Acute_CCN is not null then 1 /*Previously */ else 0 end as Specified, NSOC from( SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post_Acute_CCN_Name&apos;,     adf.ccn as &apos;post_Acute_CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor_facility_CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date_of_Birth&apos;,     dp.dod as &apos;Date_of_Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding_Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed_Physician_NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed_Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC_Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC_Network_Tier&apos;,     dn.DischargeType AS &apos;NSOC&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} ) a)b where NSOC not in (&apos;Home&apos;, &apos;Entry Error&apos;, &apos;Invalid&apos;);</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Missing NSOC" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select sum(Not_Specified) as `Missing NSOC`
from
(
select 
case when  post_Acute_CCN is null then 1
else 0
end as Not_Specified
from(
SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post_Acute_CCN_Name&apos;,
    adf.ccn as &apos;post_Acute_CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor_facility_CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date_of_Birth&apos;,
    dp.dod as &apos;Date_of_Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding_Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed_Physician_NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed_Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC_Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC_Network_Tier&apos;,
    dn.DischargeType AS &apos;Next Site of Care Category&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
and dfad.DischargeType not in (&apos;Home&apos;, &apos;Entry Error&apos;, &apos;Invalid&apos;))
a)b;</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">SNFDays_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}	
	
	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="-635229104">
                <stringProp name="213533914">select sum(Not_Specified) as `Missing NSOC` from ( select  case when  post_Acute_CCN is null then 1 else 0 end as Not_Specified from( SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post_Acute_CCN_Name&apos;,     adf.ccn as &apos;post_Acute_CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor_facility_CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date_of_Birth&apos;,     dp.dod as &apos;Date_of_Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding_Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed_Physician_NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed_Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC_Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC_Network_Tier&apos;,     dn.DischargeType AS &apos;Next Site of Care Category&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} and dfad.DischargeType not in (&apos;Home&apos;, &apos;Entry Error&apos;, &apos;Invalid&apos;)) a)b;</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="SNF CAPTURE RATE" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select 
sum(numerator)/sum(denominator) *100 as `SNF Capture Rate`
from
(
	select
	case when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Warning%&apos; or dataQualityFlag like &apos;Valid%&apos;) then  1 -- &apos;Valid SNF&apos;
	when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Invalid%&apos; or dataQualityFlag is null) then 0 -- &apos;INValid SNF&apos;
	else 0
	end as numerator
	 
	,Episodes as denominator
	from
	(
		SELECT 
		 distinct f.bundleRisk,
			CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
			CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
			dc.disagreementReasons,
			f.BPID,
			f.NSOCType,
			f.dataQualityFlag,
			de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
			de.participantNameInitCap as &apos;Participant Name&apos;,
			DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
			DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
			f.CARLstatus,
			f.episodeCountReport AS &apos;Episodes&apos;,
			adf.facilityName as &apos;post Acute CCN Name&apos;,
			adf.ccn as &apos;post Acute CCN&apos;,
			aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
			aaf.ccn as &apos;Anchor facility CCN&apos;,
			f.anchorAdmitFacilityKey,
			dp.medicareId,
			dp.patientName,
			dp.dob as &apos;Date of Birth&apos;,
			dp.dod as &apos;Date of Death&apos;,
			drg.bundleName as &apos;Bundle&apos;,
			drg.bundleCode,
			drg.drgName as &apos;DRG&apos;,
			drg.drgCode as &apos;DRG Code&apos;,
			dlos.lookupValue AS &apos;Onboarding_Status&apos;,
			dp.eligibility,
			dph.npi as &apos;Attributed Physician NPI&apos;,
			dph.physicianNameInitCap as &apos;Attributed Physician&apos;,
			#DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
			dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,
			f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,
			dn.DischargeType AS &apos;Next Site of Care Category&apos;,
			d.bundleName AS &apos;Last Working Bundle&apos;,
			d.drgCode AS &apos;Last Working DRG&apos;,
			DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
			drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
			drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
			DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
			drgfin.bundleName AS &apos;Last Final Bundle&apos;,
			drgfin.drgCode AS &apos;Last Final DRG&apos;,
			DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
			f.admissionUserEmail AS &apos;Record Creator&apos;,
			f.model,
			dles.lookupValue AS &apos;Episode Status&apos;,
			f.anchorDischargeFacilityKey,
			dloo.lookupValue AS &apos;total risk&apos;,
			aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
			afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
			dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
		FROM
			warehouse.factPatientEpisode f
				LEFT JOIN
			warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
				LEFT JOIN
			warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
			left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
				LEFT JOIN
			warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
				LEFT JOIN
			warehouse.dimCARL dc ON f.carlKey = dc.carlSK
				LEFT JOIN
			warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
				LEFT JOIN
			warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
			LEFT JOIN
			warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
				LEFT JOIN
			warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
				LEFT JOIN
			warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
				LEFT JOIN
			warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
				LEFT JOIN
			warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
				LEFT JOIN
			warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
				LEFT JOIN
			warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
				LEFT JOIN
			warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
				LEFT JOIN
			warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
				LEFT JOIN
			warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
					LEFT JOIN
			warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
		WHERE f.bundleRisk=1 
		  AND f.episodeCountReport=1 
		  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
		  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
		  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
		  AND dp.dwhSource = &apos;EC&apos;
		  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
		 -- and  f.dataQualityFlag is not null
         and dfad.DischargeType = &apos;SNF&apos;
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
	)a 
)b;</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">SNFDaysBenchmark_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}		
	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="-213194216">
                <stringProp name="666133080">select  sum(numerator)/sum(denominator) *100 as `SNF Capture Rate` from ( 	select 	case when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Warning%&apos; or dataQualityFlag like &apos;Valid%&apos;) then  1 -- &apos;Valid SNF&apos; 	when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Invalid%&apos; or dataQualityFlag is null) then 0 -- &apos;INValid SNF&apos; 	else 0 	end as numerator 	  	,Episodes as denominator 	from 	( 		SELECT  		 distinct f.bundleRisk, 			CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 			CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;, 			dc.disagreementReasons, 			f.BPID, 			f.NSOCType, 			f.dataQualityFlag, 			de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;, 			de.participantNameInitCap as &apos;Participant Name&apos;, 			DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;, 			DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;, 			f.CARLstatus, 			f.episodeCountReport AS &apos;Episodes&apos;, 			adf.facilityName as &apos;post Acute CCN Name&apos;, 			adf.ccn as &apos;post Acute CCN&apos;, 			aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;, 			aaf.ccn as &apos;Anchor facility CCN&apos;, 			f.anchorAdmitFacilityKey, 			dp.medicareId, 			dp.patientName, 			dp.dob as &apos;Date of Birth&apos;, 			dp.dod as &apos;Date of Death&apos;, 			drg.bundleName as &apos;Bundle&apos;, 			drg.bundleCode, 			drg.drgName as &apos;DRG&apos;, 			drg.drgCode as &apos;DRG Code&apos;, 			dlos.lookupValue AS &apos;Onboarding_Status&apos;, 			dp.eligibility, 			dph.npi as &apos;Attributed Physician NPI&apos;, 			dph.physicianNameInitCap as &apos;Attributed Physician&apos;, 			#DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;, 			dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;, 			f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;, 			dn.DischargeType AS &apos;Next Site of Care Category&apos;, 			d.bundleName AS &apos;Last Working Bundle&apos;, 			d.drgCode AS &apos;Last Working DRG&apos;, 			DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;, 			drgpre.bundleName AS &apos;Last Predicted Bundle&apos;, 			drgpre.drgCode AS &apos;Last Predicted DRG&apos;, 			DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;, 			drgfin.bundleName AS &apos;Last Final Bundle&apos;, 			drgfin.drgCode AS &apos;Last Final DRG&apos;, 			DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;, 			f.admissionUserEmail AS &apos;Record Creator&apos;, 			f.model, 			dles.lookupValue AS &apos;Episode Status&apos;, 			f.anchorDischargeFacilityKey, 			dloo.lookupValue AS &apos;total risk&apos;, 			aaf.sourceFacilityKey AS &apos; Facility ID&apos;, 			afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;, 			dfad.DischargeType AS &apos;NSOC Discharge Site&apos; 		FROM 			warehouse.factPatientEpisode f 				LEFT JOIN 			warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK 				LEFT JOIN 			warehouse.dimPatient dp ON f.patientKey = dp.patientSK	 			left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName 				LEFT JOIN 			warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK 				LEFT JOIN 			warehouse.dimCARL dc ON f.carlKey = dc.carlSK 				LEFT JOIN 			warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK 				LEFT JOIN 			warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK 			LEFT JOIN 			warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK 				LEFT JOIN 			warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK 				LEFT JOIN 			warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK 				LEFT JOIN 			warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK 				LEFT JOIN 			warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK 				LEFT JOIN 			warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK 				LEFT JOIN 			warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 				LEFT JOIN 			warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 				LEFT JOIN 			warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos; 				LEFT JOIN 			warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK 					LEFT JOIN 			warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK 		WHERE f.bundleRisk=1  		  AND f.episodeCountReport=1  		  AND (f.model IN (1,2)  OR f.episodeStatus=10)  		  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)  		  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 		  AND dp.dwhSource = &apos;EC&apos; 		  AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 		 -- and  f.dataQualityFlag is not null          and dfad.DischargeType = &apos;SNF&apos; ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} 	)a  )b;</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="SNF Capture Rate Errors" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select sum(Invalid) as `SNF Capture Rate Errors`
from
(
	select
	case when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Warning%&apos; or dataQualityFlag like &apos;Valid%&apos;) then  0 -- &apos;Valid SNF&apos;
	when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Invalid%&apos; or dataQualityFlag is null) then 1 -- &apos;INValid SNF&apos;
	else 0
	end as Invalid
	from
	(
		SELECT 
		 distinct f.bundleRisk,
			CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
			CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
			dc.disagreementReasons,
			f.BPID,
			f.NSOCType,
			f.dataQualityFlag,
			de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
			de.participantNameInitCap as &apos;Participant Name&apos;,
			DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
			DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;,
			f.CARLstatus,
			f.episodeCountReport AS &apos;Episodes&apos;,
			adf.facilityName as &apos;post Acute CCN Name&apos;,
			adf.ccn as &apos;post Acute CCN&apos;,
			aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
			aaf.ccn as &apos;Anchor facility CCN&apos;,
			f.anchorAdmitFacilityKey,
			dp.medicareId,
			dp.patientName,
			dp.dob as &apos;Date of Birth&apos;,
			dp.dod as &apos;Date of Death&apos;,
			drg.bundleName as &apos;Bundle&apos;,
			drg.bundleCode,
			drg.drgName as &apos;DRG&apos;,
			drg.drgCode as &apos;DRG Code&apos;,
			dlos.lookupValue AS &apos;Onboarding_Status&apos;,
			dp.eligibility,
			dph.npi as &apos;Attributed Physician NPI&apos;,
			dph.physicianNameInitCap as &apos;Attributed Physician&apos;,
			#DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
			dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;,
			f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;,
			dn.DischargeType AS &apos;Next Site of Care Category&apos;,
			d.bundleName AS &apos;Last Working Bundle&apos;,
			d.drgCode AS &apos;Last Working DRG&apos;,
			DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
			drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
			drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
			DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
			drgfin.bundleName AS &apos;Last Final Bundle&apos;,
			drgfin.drgCode AS &apos;Last Final DRG&apos;,
			DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
			f.admissionUserEmail AS &apos;Record Creator&apos;,
			f.model,
			dles.lookupValue AS &apos;Episode Status&apos;,
			f.anchorDischargeFacilityKey,
			dloo.lookupValue AS &apos;total risk&apos;,
			aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
			afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
			dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
		FROM
			warehouse.factPatientEpisode f
				LEFT JOIN
			warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
				LEFT JOIN
			warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
			left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
				LEFT JOIN
			warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
				LEFT JOIN
			warehouse.dimCARL dc ON f.carlKey = dc.carlSK
				LEFT JOIN
			warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
				LEFT JOIN
			warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
			LEFT JOIN
			warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
				LEFT JOIN
			warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
				LEFT JOIN
			warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
				LEFT JOIN
			warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
				LEFT JOIN
			warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
				LEFT JOIN
			warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
				LEFT JOIN
			warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
				LEFT JOIN
			warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
				LEFT JOIN
			warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
				LEFT JOIN
			warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
					LEFT JOIN
			warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
		WHERE f.bundleRisk=1 
		  AND f.episodeCountReport=1 
		  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
		  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
		  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)
		  AND dp.dwhSource = &apos;EC&apos;
		  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
       -- and  f.dataQualityFlag is not null
        and dfad.DischargeType = &apos;SNF&apos;
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
	)a
)b;
</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">EpisodesWithReadmission_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}		
	
	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="74777432">
                <stringProp name="1332816961">select sum(Invalid) as `SNF Capture Rate Errors` from ( 	select 	case when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Warning%&apos; or dataQualityFlag like &apos;Valid%&apos;) then  0 -- &apos;Valid SNF&apos; 	when `NSOC Discharge Site` = &apos;SNF&apos; and (dataQualityFlag like &apos;Invalid%&apos; or dataQualityFlag is null) then 1 -- &apos;INValid SNF&apos; 	else 0 	end as Invalid 	from 	( 		SELECT  		 distinct f.bundleRisk, 			CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 			CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;, 			dc.disagreementReasons, 			f.BPID, 			f.NSOCType, 			f.dataQualityFlag, 			de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;, 			de.participantNameInitCap as &apos;Participant Name&apos;, 			DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;, 			DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Discharge Date&apos;, 			f.CARLstatus, 			f.episodeCountReport AS &apos;Episodes&apos;, 			adf.facilityName as &apos;post Acute CCN Name&apos;, 			adf.ccn as &apos;post Acute CCN&apos;, 			aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;, 			aaf.ccn as &apos;Anchor facility CCN&apos;, 			f.anchorAdmitFacilityKey, 			dp.medicareId, 			dp.patientName, 			dp.dob as &apos;Date of Birth&apos;, 			dp.dod as &apos;Date of Death&apos;, 			drg.bundleName as &apos;Bundle&apos;, 			drg.bundleCode, 			drg.drgName as &apos;DRG&apos;, 			drg.drgCode as &apos;DRG Code&apos;, 			dlos.lookupValue AS &apos;Onboarding_Status&apos;, 			dp.eligibility, 			dph.npi as &apos;Attributed Physician NPI&apos;, 			dph.physicianNameInitCap as &apos;Attributed Physician&apos;, 			#DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;, 			dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC Facility&apos;, 			f.networkTierAnchDisc AS &apos;NSOC Network Tier&apos;, 			dn.DischargeType AS &apos;Next Site of Care Category&apos;, 			d.bundleName AS &apos;Last Working Bundle&apos;, 			d.drgCode AS &apos;Last Working DRG&apos;, 			DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;, 			drgpre.bundleName AS &apos;Last Predicted Bundle&apos;, 			drgpre.drgCode AS &apos;Last Predicted DRG&apos;, 			DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;, 			drgfin.bundleName AS &apos;Last Final Bundle&apos;, 			drgfin.drgCode AS &apos;Last Final DRG&apos;, 			DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;, 			f.admissionUserEmail AS &apos;Record Creator&apos;, 			f.model, 			dles.lookupValue AS &apos;Episode Status&apos;, 			f.anchorDischargeFacilityKey, 			dloo.lookupValue AS &apos;total risk&apos;, 			aaf.sourceFacilityKey AS &apos; Facility ID&apos;, 			afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;, 			dfad.DischargeType AS &apos;NSOC Discharge Site&apos; 		FROM 			warehouse.factPatientEpisode f 				LEFT JOIN 			warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK 				LEFT JOIN 			warehouse.dimPatient dp ON f.patientKey = dp.patientSK	 			left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName 				LEFT JOIN 			warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK 				LEFT JOIN 			warehouse.dimCARL dc ON f.carlKey = dc.carlSK 				LEFT JOIN 			warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK 				LEFT JOIN 			warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK 			LEFT JOIN 			warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK 				LEFT JOIN 			warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK 				LEFT JOIN 			warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK 				LEFT JOIN 			warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK 				LEFT JOIN 			warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK 				LEFT JOIN 			warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK 				LEFT JOIN 			warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 				LEFT JOIN 			warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 				LEFT JOIN 			warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos; 				LEFT JOIN 			warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK 					LEFT JOIN 			warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK 		WHERE f.bundleRisk=1  		  AND f.episodeCountReport=1  		  AND (f.model IN (1,2)  OR f.episodeStatus=10)  		  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)  		  AND aaf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 		  AND dp.dwhSource = &apos;EC&apos; 		  AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30        -- and  f.dataQualityFlag is not null         and dfad.DischargeType = &apos;SNF&apos; ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} 	)a )b;</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Action required column" enabled="true">
          <stringProp name="dataSource">MySQLQA</stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="query">select 
b.patientName, b.medicareId, 
Action_Required_For_Eligibility,
eligibility,
Action_Required_For_Onboarding,
Onboarding_Status,
case when Action_Required_For_NSOC_Completion_Status = &quot;Not Specified&quot; then &quot;Enter NSOC Information&quot; else &apos; &apos; end Action_Required_For_NSOC,
post_Acute_CCN,
case when Action_Required_For_SNF_Capture = &quot;Invalid_SNF&quot; then &quot;Update_SNF_Transition&quot; else &apos; &apos; end Action_Required_For_SNF_Capture,
dataQualityFlag,
`NSOC Discharge Site`
from
(select distinct a.patientName, a.medicareId, 
case when a.eligibility = &apos;ERROR&apos; then &apos;Set_Eligibility&apos; else &apos; &apos; end Action_Required_For_Eligibility,
a.eligibility,
case when a.Onboarding_Status = &quot;Needs Onboarding&quot; then &quot;Onboarded_Patient&quot; else &apos; &apos; end Action_Required_For_Onboarding,
a.Onboarding_Status,
case when a. post_Acute_CCN is null and `NSOC Discharge Site` not in (&apos;Home&apos;, &apos;Entry Error&apos;, &apos;Invalid&apos;)  then &quot;Not Specified&quot; else &quot;Specified&quot; end Action_Required_For_NSOC_Completion_Status,
a. post_Acute_CCN,
case when ((a.dataQualityFlag like &apos;Invalid%&apos; or a.dataQualityFlag is null) and `NSOC Discharge Site` = &apos;SNF&apos;) then &quot;Invalid_SNF&quot; Else &quot;Valid_SNF&quot; end Action_Required_For_SNF_Capture,
a.dataQualityFlag,
`NSOC Discharge Site`
from
(SELECT 
 distinct f.bundleRisk,
    CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;,
	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,
    dc.disagreementReasons,
    f.BPID,
    f.NSOCType,
    f.dataQualityFlag,
    de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,
    de.participantNameInitCap as &apos;Participant Name&apos;,
    DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,
    DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor_Discharge_Date&apos;,
    f.CARLstatus,
    f.episodeCountReport AS &apos;Episodes&apos;,
    adf.facilityName as &apos;post_Acute_CCN_Name&apos;,
    adf.ccn as &apos;post_Acute_CCN&apos;,
    aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,
    aaf.ccn as &apos;Anchor_facility_CCN&apos;,
    f.anchorAdmitFacilityKey,
    dp.medicareId,
    dp.patientName,
    dp.dob as &apos;Date_of_Birth&apos;,
    dp.dod as &apos;Date_of_Death&apos;,
    drg.bundleName as &apos;Bundle&apos;,
    drg.bundleCode,
 	drg.drgName as &apos;DRG&apos;,
    drg.drgCode as &apos;DRG Code&apos;,
    dlos.lookupValue AS &apos;Onboarding_Status&apos;,
    dp.eligibility,
    dph.npi as &apos;Attributed_Physician_NPI&apos;,
    dph.physicianNameInitCap as &apos;Attributed_Physician&apos;,
    #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,
    dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC_Facility&apos;,
    f.networkTierAnchDisc AS &apos;NSOC_Network_Tier&apos;,
    dn.DischargeType AS &apos;Next Site of Care Category&apos;,
    d.bundleName AS &apos;Last Working Bundle&apos;,
    d.drgCode AS &apos;Last Working DRG&apos;,
    DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,
    drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,
    drgpre.drgCode AS &apos;Last Predicted DRG&apos;,
    DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,
    drgfin.bundleName AS &apos;Last Final Bundle&apos;,
    drgfin.drgCode AS &apos;Last Final DRG&apos;,
    DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,
    f.admissionUserEmail AS &apos;Record Creator&apos;,
    f.model,
    dles.lookupValue AS &apos;Episode Status&apos;,
    f.anchorDischargeFacilityKey,
    dloo.lookupValue AS &apos;total risk&apos;,
    aaf.sourceFacilityKey AS &apos; Facility ID&apos;,
    afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,
    dfad.DischargeType AS &apos;NSOC Discharge Site&apos;
FROM
    warehouse.factPatientEpisode f
        LEFT JOIN
    warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK
        LEFT JOIN
    warehouse.dimPatient dp ON f.patientKey = dp.patientSK	
    left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName
        LEFT JOIN
    warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK
        LEFT JOIN
    warehouse.dimCARL dc ON f.carlKey = dc.carlSK
        LEFT JOIN
    warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK
        LEFT JOIN
    warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK
    LEFT JOIN
    warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK
        LEFT JOIN
    warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK
        LEFT JOIN
    warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK
        LEFT JOIN
    warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK
        LEFT JOIN
    warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK
        LEFT JOIN
    warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK
        LEFT JOIN
    warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK
		LEFT JOIN
    warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos;
		LEFT JOIN
    warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;
        LEFT JOIN
    warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK
            LEFT JOIN
    warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK
--         INNER JOIN 
--     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey
		LEFT JOIN
    warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK
WHERE f.bundleRisk=1 
  AND f.episodeCountReport=1 
  AND (f.model IN (1,2)  OR f.episodeStatus=10) 
  AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;) 
  AND aaf.dwhSource in (&apos;EC&apos;)
  AND dp.dwhSource = &apos;EC&apos;
  AND dloo.lookupCategory = &apos;patientRisk&apos;
AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL ${time_range} DAY) AND NOW() -- Use this query logic when filtering by Days
-- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months
-- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months
and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30
${EC_BPID}
${EC_CCN}
${EC_BUNDLE}
${EC_R_REGION} 
${EC_R_MARKET}
${EC_REGION}
${EC_MARKET}
${EC_PARTICIPANTNAME}
) a
) b 
where b.medicareId in (&apos;425876363A&apos;,&apos;621124669A&apos;,&apos;499515915A&apos;,&apos;137356807A&apos;)
and `NSOC Discharge Site` &lt;&gt; &apos;Not Available&apos;
order by b.patientName</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="variableNames">EpisodesWithReadmissionBenchmark_EC_Claims</stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
        </JDBCSampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="false">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">if(!vars.get(&quot;bpid&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BPID&quot;,&quot;and f.BPID in ${bpid}&quot;);	
} else {
	vars.put(&quot;EC_BPID&quot;,&quot;&quot;);
}
if(!vars.get(&quot;ccn&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_CCN&quot;,&quot;and aaf.ccn in ${ccn}&quot;);	
} else{
	vars.put(&quot;EC_CCN&quot;,&quot;&quot;);
}
if(!vars.get(&quot;bundle&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_BUNDLE&quot;,&quot;and drg.bundleName in ${bundle}&quot;);	
} else{
	vars.put(&quot;EC_BUNDLE&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_REGION&quot;,&quot;rmp.region in ${r_region}&quot;);	
} else {
	vars.put(&quot;EC_R_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;r_market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_R_MARKET&quot;,&quot;rmp.market in ${r_market}&quot;);	
} else{
	vars.put(&quot;EC_R_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;region&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_REGION&quot;,&quot;m.region in ${region}&quot;);	
} else {
	vars.put(&quot;EC_REGION&quot;,&quot;&quot;);
}
if(!vars.get(&quot;market&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_MARKET&quot;,&quot;m.market in ${market}&quot;);	
} else{
	vars.put(&quot;EC_MARKET&quot;,&quot;&quot;);
}
if(!vars.get(&quot;participantName&quot;).contains(&quot;Skip&quot;)){
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;and de.participantNameInitCap in ${participantName}&quot;);	
} else{
	vars.put(&quot;EC_PARTICIPANTNAME&quot;,&quot;&quot;);
}	</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <UserParameters guiclass="UserParametersGui" testclass="UserParameters" testname="User Parameters" enabled="false">
            <collectionProp name="UserParameters.names">
              <stringProp name="78391464">Query</stringProp>
              <stringProp name="0"></stringProp>
            </collectionProp>
            <collectionProp name="UserParameters.thread_values">
              <collectionProp name="-1182115093">
                <stringProp name="1648857212">select  b.patientName, b.medicareId,  Action_Required_For_Eligibility, eligibility, Action_Required_For_Onboarding, Onboarding_Status, case when Action_Required_For_NSOC_Completion_Status = &quot;Not Specified&quot; then &quot;Enter NSOC Information&quot; else &apos; &apos; end Action_Required_For_NSOC, post_Acute_CCN, case when Action_Required_For_SNF_Capture = &quot;Invalid_SNF&quot; then &quot;Update_SNF_Transition&quot; else &apos; &apos; end Action_Required_For_SNF_Capture, dataQualityFlag, `NSOC Discharge Site` from (select distinct a.patientName, a.medicareId,  case when a.eligibility = &apos;ERROR&apos; then &apos;Set_Eligibility&apos; else &apos; &apos; end Action_Required_For_Eligibility, a.eligibility, case when a.Onboarding_Status = &quot;Needs Onboarding&quot; then &quot;Onboarded_Patient&quot; else &apos; &apos; end Action_Required_For_Onboarding, a.Onboarding_Status, case when a. post_Acute_CCN is null and `NSOC Discharge Site` not in (&apos;Home&apos;, &apos;Entry Error&apos;, &apos;Invalid&apos;)  then &quot;Not Specified&quot; else &quot;Specified&quot; end Action_Required_For_NSOC_Completion_Status, a. post_Acute_CCN, case when ((a.dataQualityFlag like &apos;Invalid%&apos; or a.dataQualityFlag is null) and `NSOC Discharge Site` = &apos;SNF&apos;) then &quot;Invalid_SNF&quot; Else &quot;Valid_SNF&quot; end Action_Required_For_SNF_Capture, a.dataQualityFlag, `NSOC Discharge Site` from (SELECT   distinct f.bundleRisk,     CONCAT( &apos;Remedy-&apos;, m.region , &apos; &apos;,  m.market ) AS &apos;Remedy Region Market&apos;, 	CONCAT(de.participantShortName, &apos;-&apos;, rmp.region, &apos; &apos;,  rmp.market ) as &apos;Partner Region Market&apos;,     dc.disagreementReasons,     f.BPID,     f.NSOCType,     f.dataQualityFlag,     de.episodeInitiatorNameInitCap as &apos;Episode Intiator&apos;,     de.participantNameInitCap as &apos;Participant Name&apos;,     DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Admit Date&apos;,     DATE_FORMAT(f.anchorDischargeDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor_Discharge_Date&apos;,     f.CARLstatus,     f.episodeCountReport AS &apos;Episodes&apos;,     adf.facilityName as &apos;post_Acute_CCN_Name&apos;,     adf.ccn as &apos;post_Acute_CCN&apos;,     aaf.facilityNameInitCap AS &apos;Anchor Facility&apos;,     aaf.ccn as &apos;Anchor_facility_CCN&apos;,     f.anchorAdmitFacilityKey,     dp.medicareId,     dp.patientName,     dp.dob as &apos;Date_of_Birth&apos;,     dp.dod as &apos;Date_of_Death&apos;,     drg.bundleName as &apos;Bundle&apos;,     drg.bundleCode,  	drg.drgName as &apos;DRG&apos;,     drg.drgCode as &apos;DRG Code&apos;,     dlos.lookupValue AS &apos;Onboarding_Status&apos;,     dp.eligibility,     dph.npi as &apos;Attributed_Physician_NPI&apos;,     dph.physicianNameInitCap as &apos;Attributed_Physician&apos;,     #DATE_FORMAT(f.anchorAdmitDateKey, &quot;%Y/%m/%d&quot;) AS &apos;Anchor Begin Date&apos;,     dn.EpisodeConnect_CareSetting_CareType AS &apos;NSOC_Facility&apos;,     f.networkTierAnchDisc AS &apos;NSOC_Network_Tier&apos;,     dn.DischargeType AS &apos;Next Site of Care Category&apos;,     d.bundleName AS &apos;Last Working Bundle&apos;,     d.drgCode AS &apos;Last Working DRG&apos;,     DATE_FORMAT(f.wDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Working DRG Date&apos;,     drgpre.bundleName AS &apos;Last Predicted Bundle&apos;,     drgpre.drgCode AS &apos;Last Predicted DRG&apos;,     DATE_FORMAT(f.predDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Predicted DRG date&apos;,     drgfin.bundleName AS &apos;Last Final Bundle&apos;,     drgfin.drgCode AS &apos;Last Final DRG&apos;,     DATE_FORMAT(f.fDrgDecisionDateTimeMax, &quot;%Y-%m-%d %H:%i:%S&quot;) AS &apos;Last Final DRG Date&apos;,     f.admissionUserEmail AS &apos;Record Creator&apos;,     f.model,     dles.lookupValue AS &apos;Episode Status&apos;,     f.anchorDischargeFacilityKey,     dloo.lookupValue AS &apos;total risk&apos;,     aaf.sourceFacilityKey AS &apos; Facility ID&apos;,     afd.facilityNameInitCap AS &apos;Anchor Facility Detail&apos;,     dfad.DischargeType AS &apos;NSOC Discharge Site&apos; FROM     warehouse.factPatientEpisode f         LEFT JOIN     warehouse.dimPhysician dph ON f.physicianKey = dph.physicianSK         LEFT JOIN     warehouse.dimPatient dp ON f.patientKey = dp.patientSK	     left join warehouse.dimLookup dloo on dp.totalRiskScore = dloo.lookupName         LEFT JOIN     warehouse.dimEpisodeInitiator de ON f.episodeInitiatorKey = de.episodeInitiatorSK         LEFT JOIN     warehouse.dimCARL dc ON f.carlKey = dc.carlSK         LEFT JOIN     warehouse.dimFacility aaf ON f.anchorAdmitFacilityKey = aaf.facilitySK         LEFT JOIN     warehouse.dimFacility adf ON f.anchorDischargeFacilityKey = adf.facilitySK     LEFT JOIN     warehouse.dimFacility afd ON f.sourceFacilityKey = afd.facilitySK         LEFT JOIN     warehouse.dimDRG drg ON f.currDrgKey = drg.drgSK         LEFT JOIN     warehouse.dimDRG d ON f.wDrgKeyMax = d.drgSK         LEFT JOIN     warehouse.dimDRG drgpre ON f.predDrgKeyMax = drgpre.drgSK         LEFT JOIN     warehouse.dimDRG drgfin ON f.fDrgKeyMax = drgfin.drgSK         LEFT JOIN     warehouse.dimNSOCMapping dn ON f.anchorDischCareSettingKey = dn.NSOCMappingSK         LEFT JOIN     warehouse.dimDate dt ON f.anchorAdmitDateKey = dt.dateSK 		LEFT JOIN     warehouse.dimLookup dles ON f.episodeStatus = dles.lookupName AND dles.lookupCategory = &apos;episodeStatus&apos; 		LEFT JOIN     warehouse.dimLookup dlos ON dp.onboardingStatus = dlos.lookupName AND dlos.lookupCategory = &apos;onboardingStatus&apos;         LEFT JOIN     warehouse.dimRegionMarket m ON f.rgRemKey = m.rgSK             LEFT JOIN     warehouse.dimRegionMarket rmp ON f.rgPartnerKey = rmp.rgSK --         INNER JOIN  --     warehouse.factAdmission fa ON f.anchorAdmissionKey = fa.anchorAdmissionKey 		LEFT JOIN     warehouse.dimNSOCMapping dfad ON f.anchorDischCareSettingKey = dfad.NSOCMappingSK WHERE f.bundleRisk=1    AND f.episodeCountReport=1    AND (f.model IN (1,2)  OR f.episodeStatus=10)    AND adf.dwhSource in (&apos;EC&apos;,&apos;ZeroKey&apos;)    AND aaf.dwhSource in (&apos;EC&apos;)   AND dp.dwhSource = &apos;EC&apos;   AND dloo.lookupCategory = &apos;patientRisk&apos; AND dt.calendarDate BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() -- Use this query logic when filtering by Days -- and f.anchorAdmitDateKey &gt;= &apos;20160501&apos; -- Use this query logic when filtering by Months -- and f.anchorAdmitDateKey &lt;= &apos;20181031&apos; -- Use this query logic when filtering by Months and f.anchorAdmitDateKey &lt; (select CAST(lookupValue AS UNSIGNED)from warehouse.dimLookup where lookupCategory = &apos;BPCIAStartDate&apos;) -- This additional condition basically restricts this extract to fetch data only until BPCI 1.0 cut off date - 9/30 ${EC_BPID} ${EC_CCN} ${EC_BUNDLE} ${EC_R_REGION}  ${EC_R_MARKET} ${EC_REGION} ${EC_MARKET} ${EC_PARTICIPANTNAME} ) a ) b  where b.medicareId in (&apos;425876363A&apos;,&apos;621124669A&apos;,&apos;499515915A&apos;,&apos;137356807A&apos;) and `NSOC Discharge Site` &lt;&gt; &apos;Not Available&apos; order by b.patientName</stringProp>
                <stringProp name="0"></stringProp>
              </collectionProp>
            </collectionProp>
            <boolProp name="UserParameters.per_iteration">false</boolProp>
          </UserParameters>
          <hashTree/>
        </hashTree>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <SystemSampler guiclass="SystemSamplerGui" testclass="SystemSampler" testname="OS Process Sampler" enabled="true">
          <boolProp name="SystemSampler.checkReturnCode">false</boolProp>
          <stringProp name="SystemSampler.expectedReturnCode">0</stringProp>
          <stringProp name="SystemSampler.command">cmd.exe</stringProp>
          <elementProp name="SystemSampler.arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="Argument">
                <stringProp name="Argument.name"></stringProp>
                <stringProp name="Argument.value">/c</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="" elementType="Argument">
                <stringProp name="Argument.name"></stringProp>
                <stringProp name="Argument.value">echo KPI_Episode_EC_Claims=${Episode_EC_Claims_1}*Savings Rate_EC_Claims=${savingRate_EC_Claims_1}*KPI_NPRA_EC_Claims=${TotalNPRA_EC_Claims_1}*KPI_Program_size_EC_Claims=${TotalProgram_EC_Claims_1}*% SNF Disch Current_EC_Claims=${DischargeToSNF_EC_Claims_1}*SNF Days Current_EC_Claims=${SNFDays_EC_Claims_1}*SNF Days Benchmark Variance_EC_Claims=${SNFDaysBenchmark_EC_Claims_1}*Readmissions Current_EC_Claims=${EpisodesWithReadmission_EC_Claims_1}*Readmissions Benchmark Variance_EC_Claims=${EpisodesWithReadmissionBenchmark_EC_Claims_1}*% SNF Disch Benchmark Variance_EC_Claims=${dischtoSNFBenchmark_EC_Claims_1}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <elementProp name="SystemSampler.environment" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="SystemSampler.directory">${__BeanShell(import org.apache.jmeter.services.FileServer; FileServer.getFileServer().getBaseDir();)}${__BeanShell(File.separator,)}</stringProp>
        </SystemSampler>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.apache.jmeter.services.FileServer;
//get current jmeter script&apos;s directory
String path = FileServer.getFileServer().getBaseDir();
 
//get the separator
String separator = File.separator;
 
log.info(&quot;Path: &quot; + path);
log.info(&quot;Path with separator: &quot; + path + separator);
System.out.print(path+separator);
System.out.println(${Flag});
if(vars.get(&quot;Flag&quot;).equals(&quot;(1)&quot;)){
	log.info(&quot;Path: 1&quot;);
	fA = new FileOutputStream(path+separator+&quot;IPECECMetricsOutput.txt&quot;);
	pA = new PrintStream(fA); 
	pA.print(&quot;&quot;);
	pA.close();
	fA.close();
	}
log.info(&quot;Path: 7&quot;);
f= new FileOutputStream(path + separator+&quot;IPECECMetricsOutput.txt&quot;,true);
	p = new PrintStream(f);
	String Episode_EC_Claims_1=vars.get(&quot;${Episode_EC_Claims_1}&quot;);
	String savingRate_EC_Claims_1=vars.get(&quot;${savingRate_EC_Claims_1}&quot;);
	String TotalNPRA_EC_Claims_1=vars.get(&quot;${TotalNPRA_EC_Claims_1}&quot;);
	String TotalProgram_EC_Claims_1=vars.get(&quot;${TotalProgram_EC_Claims_1}&quot;);
	String DischargeToSNF_EC_Claims_1=vars.get(&quot;${DischargeToSNF_EC_Claims_1}&quot;);
	String SNFDays_EC_Claims_1=vars.get(&quot;${SNFDays_EC_Claims_1}&quot;);
	String SNFDaysBenchmark_EC_Claims_1=vars.get(&quot;${SNFDaysBenchmark_EC_Claims_1}&quot;);
	String EpisodesWithReadmissionBenchmark_EC_Claims_1=vars.get(&quot;${EpisodesWithReadmissionBenchmark_EC_Claims_1}&quot;);
	String dischtoSNFBenchmark_EC_Claims_1=vars.get(&quot;${dischtoSNFBenchmark_EC_Claims_1}&quot;);
	p.println(&quot;KPI_Episode_EC_Claims=&quot;+Episode_EC_Claims_1+&quot;*Savings Rate_EC_Claims=&quot;+savingRate_EC_Claims_1+&quot;*KPI_NPRA_EC_Claims=&quot;+TotalNPRA_EC_Claims_1+&quot;*KPI_Program_size_EC_Claims=&quot;+TotalProgram_EC_Claims_1+&quot;*% SNF Disch Current_EC_Claims=&quot;+DischargeToSNF_EC_Claims_1+&quot;*SNF Days Current_EC_Claims=&quot;+SNFDays_EC_Claims_1+&quot;*SNF Days Benchmark Variance_EC_Claims=&quot;+SNFDaysBenchmark_EC_Claims_1+&quot;*Readmissions Current_EC_Claims=&quot;+EpisodesWithReadmission_EC_Claims_1+&quot;*Readmissions Benchmark Variance_EC_Claims=&quot;+EpisodesWithReadmissionBenchmark_EC_Claims_1+&quot;*% SNF Disch Benchmark Variance_EC_Claims=&quot;+dischtoSNFBenchmark_EC_Claims_1);
p.close();
f.close();
</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
